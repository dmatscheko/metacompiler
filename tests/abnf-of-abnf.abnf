:title("ABNF of ABNF to a-grammar") ;
:description("This ABNF contains the grammatic and semantic information for annotated EBNF.
It allows to automatically create a compiler for everything described in ABNF (yes, that format).") ;


// TODO: implement !"asdf", !@"asdf", and !@+"asdf", and maybe @b"asdf", and @b+"asdf", and !@b"asdf", and !@b+"asdf".


// --- main rules

:startRule(ABNF) ;
// This is a parser command that sets the possible white space.
:whitespace(Whitespace) ;

// This is the start rule.
ABNF        = { Production | LineCommand } ;

Production  = Name <~~ var prodTag=undefined; var prodExpression=undefined; pushg(pop()) ~~> [ Tag <~~ prodTag=pop() ~~> ] "=" [ Expression <~~ prodExpression=pop() ~~> ] ";" <~~  pushg(buildProduction(popg(), prodTag, prodExpression)) ~~> ;

Expression  = Alternative ;

Alternative <~~ push(simplify(abnf.newAlternative(popg(), c.Pos))) ~~>
            = Sequence <~~ pushg([pop()]) ~~> { "|" Sequence <~~ pushg(append(popg(), pop())) ~~> } ;

Sequence    <~~ push(simplify(abnf.newSequence(popg(), c.Pos))) ~~>
            = Term <~~ pushg([pop()]) ~~> { Term <~~ pushg(append(popg(), pop())) ~~> } ;

Term        <~~ push(popg()) ~~>
            = ( Name | ByteRange | Range | CharsOf | CharOf | Group | Option | Repetition | Times | Command ) <~~ pushg(simplify(pop())) ~~> [ Tag <~~ var tag=pop(); tag.Childs=simplifyToArr(popg()); pushg(tag) ~~> ] ;

Group       = "(" Expression <~~ push(abnf.newGroup(simplifyToArr(pop()), c.Pos)) ~~> ")" ;
Option      = "[" Expression <~~ push(abnf.newOption(simplifyToArr(pop()), c.Pos)) ~~> "]" ;
Repetition  = "{" Expression <~~ push(abnf.newRepetition(simplifyToArr(pop()), c.Pos)) ~~> "}" ;
Range       <~~ push(popg()) ~~>
            = Token <~~ pushg(pop()) ~~> [ "..." Token <~~ pushg(abnf.newRange([popg(), pop()], abnf.rangeType.Rune, c.Pos)) ~~> ] ;
ByteRange   = Token <~~ pushg(pop()) ~~> "..b" Token <~~ push(abnf.newRange([popg(), pop()], abnf.rangeType.Byte, c.Pos)) ~~> ;
CharsOf     = "@+" Token <~~ push(abnf.newCharsOf(pop().String, c.Pos)) ~~> ;
CharOf      = "@" Token <~~ push(abnf.newCharOf(pop().String, c.Pos)) ~~> ;
Times       = CmdNumber <~~ pushg([pop()]) ~~> [ "..." ( CmdNumber | "" <~~ push(abnf.newToken("...")) ~~> ) <~~ pushg(append(popg(), pop())) ~~> ] Group <~~ push(abnf.newTimes(popg(), simplifyToArr(pop()), c.Pos)) ~~> ;

CmdNumber   = Number | Command ;

LineCommand = Command <~~ pushg(buildLineCommand(pop())) ~~> ";" ;
Command     <~~ push(abnf.newCommand(pop(), popg(), c.Pos)) ~~>
            = ":" CmdName "(" <~~ pushg([]) ~~> [ ( Name | Token | Number ) <~~ pushg(append(popg(), pop())) ~~> { "," ( Name | Token | Number ) <~~ pushg(append(popg(), pop())) ~~> } ] ")" ;

Tag         <~~ push(abnf.newTag(popg(), undefined, c.Pos)) ~~>
            = "<" ( Name | Token ) <~~ pushg([pop()]) ~~> { "," ( Name | Token ) <~~ pushg(append(popg(), pop())) ~~> } ">" ;

Name        <~~ push(abnf.newIdentifier(up.in, getNameIdx(up.in), c.Pos)) ~~>
            = Alphabet :whitespace() { Alphabet | Digit | "_" } :whitespace(Whitespace) ;
CmdName     <~~ push(up.in) ~~>
            = Alphabet :whitespace() { Alphabet | Digit | "_" } :whitespace(Whitespace) ;

Token       = Dquotetoken | Squotetoken | Code ;
Dquotetoken = '"' :whitespace() { AsciiNoQs | "'" | '\\"' } <~~ push(abnf.newToken(unescape(up.in), c.Pos)) ~~> '"' :whitespace(Whitespace) ;
Squotetoken = "'" :whitespace() { AsciiNoQs | '"' | "\\'" } <~~ push(abnf.newToken(unescape(up.in), c.Pos)) ~~> "'" :whitespace(Whitespace) ;
Code        = '~~' :whitespace() { [ "~" ] AllButTilde } <~~ push(abnf.newToken(unescapeTilde(up.in), c.Pos)) ~~> '~~' :whitespace(Whitespace) ;

Alphabet    = "a"..."z" | "A"..."Z" ;
Digit       = "0"..."9" ;
AsciiNoQs   = "\x28"..."\x7e" | "\x23"..."\x26" | @"\t\n\r !" ; // Readable ASCII without double and single quotes.
AsciiNoLb   = " "..."~" | "\t" ; // Readable ASCII without line breaks (CR and LF).
AsciiNoStSl = "\x00"...")" | "+"..."." | "0"..."~" ; // All ASCII without star (*) and slash (/).
AllButTilde = "\x00"..."}" | "\\~" | "\x7f"..."\uffff" ; // All ASCII and unicode chars. Only tilde is escaped.

Number      <~~ push(abnf.newNumber(up.in, c.Pos)) ~~>
            = "0" | "1"..."9" { "0"..."9" } ;

Whitespace  = { @+"\t\n\r " | Comment } ;

Comment     = LineComment | "/*" :whitespace() { { "*" } AsciiNoStSl { "/" } } "*/" :whitespace(Whitespace) ;
LineComment = "//" :whitespace() { AsciiNoLb } ( "\n" | "\r" ) :whitespace(Whitespace) ;

// ---


:startScript(~~

    let names = []
    let prodsPos = {}
    let lastPos = 0

    function getNameIdx(name) {
        const pos = names.indexOf(name)
        if (pos != -1) return pos
        return names.push(name) - 1
    }
    function resolveNameIdx(productions) {
        for (let i = 0; i < productions.length; i++) {
            let rule = productions[i]
            if (rule.Childs != undefined && rule.Childs.length > 0) resolveNameIdx(rule.Childs)
            if (rule.CodeChilds != undefined && rule.CodeChilds.length > 0) resolveNameIdx(rule.CodeChilds)
            if (rule.Operator == abnf.oid.Production || rule.Operator == abnf.oid.Identifier) rule.Int = prodsPos[rule.Int]
        }
    }
    function buildProduction(prodName, prodTag, prodExpression) {
        if (prodsPos[prodName.Int] != undefined) {
            println("Error: Rule " + prodName.String + " is defined multiple times.")
            exit(0)
        }
        prodsPos[prodName.Int] = lastPos++
        if (prodTag != undefined) {
            prodTag.Childs = simplifyToArr(prodExpression)
            return abnf.newProduction(prodName.String, prodName.Int, [prodTag], prodName.Pos)
        } else {
            return abnf.newProduction(prodName.String, prodName.Int, simplifyToArr(prodExpression), prodName.Pos)
        }
    }
    function buildLineCommand(cmd) {
        prodsPos[getNameIdx(cmd.String)] = lastPos++
        return cmd
    }

    // This breaks up an abnf.oid.Group. Use only for childs of unbreakable rules.
    function simplifyArr(rules) {
        if (rules.length == 1) {
            const op = rules[0].Operator
            if (op == abnf.oid.Sequence || op == abnf.oid.Group || (op == abnf.oid.Or && rules[0].Childs.length <= 1)) return simplifyArr(rules[0].Childs)
        }
        return rules
    }

    // This also breaks up an abnf.oid.Group. Use only for childs of unbreakable rules.
    function simplifyToArr(rule) {
        if (rule == undefined) return undefined
        return simplifyArr([rule])
    }

    // Groups with only one child can be broken apart as long as down there is an unbreakable rule. Try to find one.
    function trySimplifyDown(rule) {
        if (rule.Childs == undefined) return rule
        const op = rule.Operator
        if ((rule.Childs.length == 1) && (op == abnf.oid.Sequence || op == abnf.oid.Group || op == abnf.oid.Or)) return trySimplifyDown(rule.Childs[0])
        if (op == abnf.oid.Sequence) return undefined
        return rule
    }

    function simplify(rule) {
        let ruleDown = trySimplifyDown(rule)
        if (ruleDown != undefined) return ruleDown
        if (rule.Childs.length == 1) { // Breaking up abnf.oid.Group did not work. Getting down only with Sequence and Or.
            const op = rule.Operator
            if (op == abnf.oid.Sequence || op == abnf.oid.Or) return simplify(rule.Childs[0])
        }
        return rule
    }

    c.compile(c.asg)
    let rules = ltr.stack
    resolveNameIdx(rules)

    // To show the initial a-grammar:
    println("=> Rules: " + abnf.serializeRules(rules))

    // To return the generated a-grammar to the next parser:
    rules

~~) ;
