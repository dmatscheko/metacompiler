"ABNF of ABNF: Compiles to textual a-grammar"
<~~
var names = [];
function getNameIdx(name) {
    var pos = names.indexOf(name);
    if (pos != -1) { return pos };
    return names.push(name)-1;
}
c.compile(c.asg)
~~>

{

ABNF                                   <~~push(up.in)~~>
                =
                [
                    Title               <~~ up.in += ', \n' ~~>
                ]
                Programtag
                "{"                     <~~ up.in = '\n{\n\n' ~~>
                { Production }
                "}"                     <~~ up.in = '\n}, \n\n' ~~>
                Programtag
                start
                [
                    Comment             <~~ up.in = ', \n'+up.in+'\n' ~~>
                ] ;

Programtag      =
                [
                    Tag                 <~~ up.in = '{"TAG", '+up.in+'}, \n' ~~>
                ] ;

Production                              <~~ var productionTag = pop();
                                        if (productionTag != undefined) {
                                            pop()/*=undefined*/;
                                            up.in = '{"TAG", '+productionTag+', '+up.in+'}'
                                        };
                                        up.in += ',\n' ~~>       
                =
                Name                    <~~ up.in = '{"'+up.in+'", '+getNameIdx(up.in)+', ';
                                        push(undefined) ~~>
                [
                    Tag                 <~~ push(up.in); up.in = '' ~~>
                ]
                "="                     <~~up.in=''~~>
                [ Expression ]
                ";"                     <~~ up.in = '}' ~~> ;

Expression                              <~~ if (/*or*/ pop()) {
                                            up.in = '{"OR", '+up.in+'}'
                                        } ~~>
                =
                Alternative             <~~ /*or=false*/ push(false); ~~>
                {
                    "|"                 <~~up.in=''~~>
                    Alternative         <~~ /*or=true*/ pop();push(true); up.in = ', '+up.in ~~>
                } ;

Alternative     =
                Taggedterm
                {
                    Taggedterm          <~~ up.in = ', '+up.in ~~>
                } ;

Taggedterm                              <~~up.in=pop()~~>
                =
                Term                    <~~push(up.in)~~>
                [
                    Tag                 <~~ push('{"TAG", '+up.in+', '+pop()+'}') ~~>
                ] ;

Term            =
                (
                    Name                <~~ up.in = '{"IDENT", "'+up.in+'", '+getNameIdx(up.in)+'}' ~~>
                    |
                    ( Token [ "..." Token ] )
                    |
                    Group
                    |
                    Option
                    |
                    Repetition
                    |
                    skipspaces
                ) ;

Group           <~~ up.in = '{'+pop()+'}' ~~>                    = "(" Expression <~~push(up.in)~~> ")" ;
Option          <~~ up.in = '{"OPTIONAL", '+pop()+'}' ~~>        = "[" Expression <~~push(up.in)~~> "]" ;
Repetition      <~~ up.in = '{"REPEAT", '+pop()+'}' ~~>          = "{" Expression <~~push(up.in)~~> "}" ;
skipspaces      =
                "+"                     <~~ up.in = '{"SKIPSPACES", true}' ~~>
                |
                "-"                     <~~ up.in = '{"SKIPSPACES", false}' ~~> ;

Title           = Token ;
start           = Name                  <~~ up.in = '{"IDENT", "'+up.in+'", '+getNameIdx(up.in)+'}' ~~> ;
Comment         = Token ;

Tag                                     <~~up.in=pop()~~>
                =
                "<"
                Code                    <~~push(up.in)~~>
                {
                    ","
                    Code                <~~ push(pop()+', '+up.in) ~~>
                }
                ">" ;

Code                                    <~~ up.in = '{"TOKEN", '+sprintf("%q",pop())+'}' ~~>
                =
                '~~'
                -
                { [ "~" ] Codeinner }   <~~push(up.in)~~>
                '~~'
                + ;

Codeinner       = Small | Caps | Digit | Special | "'" | '"' | "\\~" ;

Name            = ( Small | Caps ) - { Small | Caps | Digit | "_" } + ;

Token                                   <~~ up.in = '{"TOKEN", '+sprintf("%q",pop())+'}' ~~>
                = Dqtoken | Sqtoken ;
Dqtoken         = '"' - { Small | Caps | Digit | Special | "~" | "'" | '\\"' } <~~push(up.in)~~> '"' + ;
Sqtoken         = "'" - { Small | Caps | Digit | Special | "~" | '"' | "\\'" } <~~push(up.in)~~> "'" + ;

Digit           = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
Small           = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" |
                  "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
Caps            = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" |
                  "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
Special         = "_" | " " | "." | "," | ":" | ";" | "!" | "?" | "+" | "-" | "*" | "/" | "=" |
                  "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">" | "|" | "%" | "$" | "&" | "#" |
                  "@" | "\\\\" | "\\t" | "\t" | "\\n" | "\n" | "\\r" | "\r" ;

}

<~~ print(pop()) ~~>
ABNF
"This ABNF contains the grammatic and semantic information for annotated EBNF.
It allows to automatically create a compiler for everything described in ABNF (yes, that format)."
