:title("Tiny C-ish language") ;


:startRule(Program) ;
:whitespace(Whitespace) ;

Program     = { Function } ;

Function    =
            "func"
            Id              <~~ pushg(up.in) ~~>
            Parameter       <~~ var params = popg(); var fid = popg(); var f = m.NewFunc(fid, i32, params); var b = f.NewBlock(""); ~~>
            Statement ;

Parameter   =
            "(" <~~ pushg([]) ~~>
                [
                    ParamDecl <~~ pushg(append(popg(), llvm.ir.NewParam(pop(), i32))) ~~>
                    { "," ParamDecl <~~ pushg(append(popg(), llvm.ir.NewParam(pop(), i32))) ~~> }
                ]
            ")" ;
ParamDecl   = "int" Id <~~ push(up.in) ~~> ;

Statement   <~~ push({inB: f.NewBlock(""), outB: f.NewBlock("")}); b.NewRet(zero) ~~> // TODO
            = IfElse | If | For | While | Do | Return | Block | SingleStmt | ZeroStmt ;

// Each Statement, except the ones that are blank expressions, is a new variable scope. New scope: pushScope(), return to parent scope: popScope().
// Each Statement must push itself on local stack and must consist of two blocks: {inB: beginBlock, outB: endblock}.
IfElse      = "if" <~~ pushScope() ~~> ParenExpr1 <~~ pushg(pop()) ~~> Statement <~~ pushg(pop()) ~~> "else" Statement <~~ var trueB = popg(); var falseB = pop(); var comp = popg(); push(newIf(comp, trueB, falseB)); popScope() ~~> ;
If          = "if" <~~ pushScope() ~~> ParenExpr1 <~~ pushg(pop()) ~~> Statement <~~ push(newIf(popg(), pop())); popScope() ~~> ;
For         = "for" <~~ pushScope() ~~> ParenExpr3 Statement <~~ popScope() ~~> ;
While       = "while" <~~ pushScope() ~~> ParenExpr1 Statement <~~ popScope() ~~> ;
Do          = "do" <~~ pushScope() ~~> Statement "while" ParenExpr1 ";" <~~ popScope() ~~> ;
Return      = "return" [ ResultExpr ] ";" ;
Block       = "{" <~~ pushScope() ~~> { Statement } "}" <~~ popScope() ~~> ;
SingleStmt  = Expression ";" ;
ZeroStmt    = ";" ;

ParenExpr1  =  "(" ResultExpr ")" ;
ParenExpr3  =  "(" [ Declaration ] ";" [ ResultExpr ] ";" [ Expression ] ")" ;

Expression  = VoidExpr | ResultExpr ;
VoidExpr    = Declaration | Assignment ;
ResultExpr  = Test ;

Declaration = ( AssignDecl | OnlyDecl ) { "," Declaration } ; // The ugly comma-declaration-method only because of the stupid decision to separate the entries in a for-loop with semicolon instead of comma.

AssignDecl  <~~ var vp = null; ~~>
            = "int" <~~ var vp = newVar(zero); /* vp is necessary here, because it is used at Assignment */ ~~>
            Assignment ;

OnlyDecl    = "int" Id <~~ setVar(up.in, newVar(zero)); ~~> ;

Assignment  <~~ var expr = pop(); var id = pop(); if (!vp) { vp = getVar(id) }; var exprv = b.NewLoad(i32, expr); b.NewStore(exprv, vp); setVar(id, vp) ~~>
            = Id <~~ push(up.in) ~~> "=" ResultExpr ;

Test        = Comp                  <~~ pushg(pop()) ~~>
                ( "||" | "&&" )     <~~ pushg(pop()) ~~>
                Comp                <~~ var vb = pop(); var op = popg(); var va = popg(); push(boolean(va, vb, op)) ~~>
            | Comp ;

Comp        = Sum                                           <~~ pushg(pop()) ~~>
                ( "<" | ">" | "<=" | ">=" | "==" | "!=" )   <~~ pushg(up.in) ~~>
                Sum                                         <~~ var vb = pop(); var op = popg(); var va = popg(); push(compare(va, vb, op)) ~~>
            | Sum ;

Sum         = Term <~~ pushg(pop()) ~~> "+" Term <~~ var v1 = popg(); var v2 = pop(); var v = b.NewAdd(b.NewLoad(i32, v1), b.NewLoad(i32, v2)); var vp = newVar(v); push(vp); ~~>
            | Term <~~ pushg(pop()) ~~> "-" Term <~~ var v1 = popg(); var v2 = pop(); var v = b.NewSub(b.NewLoad(i32, v1), b.NewLoad(i32, v2)); var vp = newVar(v); push(vp); ~~>
            | Id <~~ pushg(up.in) ~~> "++" <~~ var vp = getVar(popg()); var v = b.NewAdd(b.NewLoad(i32, vp), one); b.NewStore(v, vp); push(vp); ~~>
            | Id <~~ pushg(up.in) ~~> "--" <~~ var vp = getVar(popg()); var v = b.NewSub(b.NewLoad(i32, vp), one); b.NewStore(v, vp); push(vp); ~~>
            | Term ;

Term        = ParenExpr1
            | Call
            | Id    <~~ push(getVar(up.in)) ~~>
            | Int ;

Call        = Id        <~~ pushg(up.in) ~~> 
            "("         <~~ pushg([]); var paramsInterface = []; ~~>
                [
                    ResultExpr      <~~ pushg(append(popg(), pop())); paramsInterface.push(llvm.ir.NewParam("", i32)); ~~>
                    {
                        ","
                        ResultExpr  <~~ pushg(append(popg(), pop())); paramsInterface.push(llvm.ir.NewParam("", i32)); ~~>
                    }
                ]
            ")" <~~ var params = popg(); var id = popg(); push(b.NewCall(m.NewFunc(id, i32, paramsInterface), params)); ~~> ;

Id          = ( "a"..."z" | "A"..."Z" ) :whitespace() { "a"..."z" | "A"..."Z" | "_" } :whitespace(Whitespace) ;
Int         <~~ push(newVar(llvm.constant.NewInt(i32, parseInt(up.in)))) ~~>
            = "0" | "1"..."9" :whitespace() { "0"..."9" } :whitespace(Whitespace) ;

Whitespace  = @+" \t\r\n" ;


:startScript(~~

var i32 = llvm.types.I32
// var i32p = llvm.types.I32Ptr
var zero = llvm.constant.NewInt(i32, 0)
var one = llvm.constant.NewInt(i32, 1)

var m = llvm.ir.NewModule()

var f = m.NewFunc("_init", i32, null)
var b = f.NewBlock("")
b.NewCall(m.NewFunc("main", i32, null))
b.NewRet(zero)

// TODO: Push scoped variables into up.arrXYZ.
var vars = {}

function newVar(v) {
    var vx = b.NewAlloca(i32)
    var vp = b.NewGetElementPtr(i32, vx, zero)
    b.NewStore(v, vp);
    return vp
}

function getVar(id) {
    for (var i = 0; i<f.Params.length; i++) {
        if (f.Params[i].LocalName == id) {
            var vx = b.NewAlloca(i32)
            var vp = b.NewGetElementPtr(i32, vx, zero)
            b.NewStore(f.Params[i], vp)
            return vp
        } 
    }
    if (vars[id] != null) return vars[id]
    println("Error: Variable not defined: " + id)
    exit(1)
}

function setVar(id, vp) {
    vars[id] = vp
}

function compare(vpa, vpb, op) {
    if (vpa == null) {
        println("Error in compare(): va is not defined.")
    }
    if (vpb == null) {
        println("Error in compare(): vb is not defined.")
    }
    var comperator = null
    if (op == "<") {
        comperator = llvm.enum.IPredULT
    } else if (op == ">") {
        comperator = llvm.enum.IPredUGT
    } else if (op == "<=") {
        comperator = llvm.enum.IPredULE
    } else if (op == ">=") {
        comperator = llvm.enum.IPredUGE
    } else if (op == "==") {
        comperator = llvm.enum.IPredEQ
    } else if (op == "!=") {
        comperator = llvm.enum.IPredNE
    }

    var va = vpa
    var vb = vpb
    if (llvm.types.IsPointer(vpa.Typ)) {
        va = b.NewLoad(i32, vpa)
    }
    if (llvm.types.IsPointer(vpb.Typ)) {
        vb = b.NewLoad(i32, vpb)
    }

    var condition = b.NewICmp(comperator, va, vb)
    // printf("Cond: %#v\n", condition)
    return condition
}

function boolean(vpa, vpb, op) {
    if (vpa == null) {
        println("Error in compare(): va is not defined.")
    }
    if (vpb == null) {
        println("Error in compare(): vb is not defined.")
    }
    var operator = null
    if (op == "&&") {
        operator = "=="
    } else if (op == "||") {
        operator = "!="
    }

    var va = vpa
    if (llvm.types.IsPointer(vpa.Typ)) {
        va = b.NewLoad(i32, vpa)
    }

    var resultp = newVar(va)

    var conditionVa = compare(va, zero, operator)

    var endB = f.NewBlock("")   // every block of this function must end here
    var secondB = f.NewBlock("")

    b.NewCondBr(conditionVa, endB, secondB)

    // inside second branch
    b = secondB

    var vb = vpb
    if (llvm.types.IsPointer(vpb.Typ)) {
        vb = b.NewLoad(i32, vpb)
    }
    b.NewStore(vb, resultp)
    b.NewBr(endB)

    // inside end branch
    b = endB
    return resultp

    // https://stackoverflow.com/questions/11485531/what-exactly-phi-instruction-does-and-how-to-use-it-in-llvm
}

// All Statements must return two values: {inB, outB}
function newIf(test, trueStmt, falseStmt) {        // TODO: stmt = {inB, outB}
    var inB = f.NewBlock("")
    var outB = f.NewBlock("")

    var origB = b
    b = inB

    var condition = compare(test, zero, "!=")

    trueStmt.outB.NewBr(outB)
    if (falseStmt == null) {
        b.NewCondBr(condition, trueStmt.InB, outB)
    } else {
        falseStmt.outB.NewBr(outB)
        b.NewCondBr(condition, trueStmt.InB, falseStmt.inB)
    }

    b = origB

    return {inB: inB, outB: outB}
}


// var func = m.NewFunc("name", i32)
// var block = func.NewBlock("name")

// function buildFunction(stmt, params, id) {
//     var f = m.NewFunc(id, i32, params)
//     f.NewBlock("").NewBr(stmt)
//     push(f)
// }

c.compile(c.asg)
println(m)

~~) ;
