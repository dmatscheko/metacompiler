"aEBNF of aEBNF as text"
<~~
var names = [];
function getNameIdx(name) {
  var pos = names.indexOf(name);
  if (pos != -1) { return pos };
  return names.push(name)-1;
}
c.compile(c.asg, up.in)
~~>

{

program								<~~push(up.in)~~>
				=
				[
					title			<~~ up.in += ', \\n' ~~>
				]
				programtag
				"{"					<~~ up.in = '\\n{\\n\\n' ~~>
				{ production }
				"}"					<~~ up.in = '\\n}, \\n\\n' ~~>
				programtag
				start
				[
					comment			<~~ up.in = ', \\n'+up.in+'\\n' ~~>
				] ;

programtag		=
				[
					tag				<~~ up.in = '{"TAG", '+up.in+'}, \\n' ~~>
				] ;

production								<~~ var productionTag = pop();
										if (productionTag != undefined) {
											pop()/*=undefined*/;
											up.in = '{"TAG", '+productionTag+', '+up.in+'}'
										};
										up.in += ',\\n' ~~>       
				=
				name					<~~ up.in = '{"'+up.in+'", '+getNameIdx(up.in)+', ';
										push(undefined) ~~>
				[
					tag					<~~ push(up.in); up.in = '' ~~>
				]
				"="						<~~up.in=''~~>
				[ expression ]
				( "." | ";" )			<~~ up.in = '}' ~~> ;

expression       						<~~ if (/*or*/ pop()) {
											up.in = '{"OR", '+up.in+'}'
										} ~~>
				=
				alternative				<~~ /*or=false*/ push(false); ~~>
				{
					"|"					<~~up.in=''~~>
					alternative			<~~ /*or=true*/ pop();push(true); up.in = ', '+up.in ~~>
				} ;

alternative		=
				taggedterm
				{
					taggedterm			<~~ up.in = ', '+up.in ~~>
				} ;

taggedterm								<~~up.in=pop()~~>
				=
				term					<~~push(up.in)~~>
				[
					tag					<~~ push('{"TAG", '+up.in+', '+pop()+'}') ~~>
				] ;

term			=
				(
					name				<~~ up.in = '{"IDENT", "'+up.in+'", '+getNameIdx(up.in)+'}' ~~>
					|
					( text [ "..." text ] )
					|
					group
					|
					option
					|
					repetition
					|
					skipspaces
				) ;

group			<~~ up.in = '{'+pop()+'}' ~~>					= "(" expression <~~push(up.in)~~> ")" ;
option			<~~ up.in = '{"OPTIONAL", '+pop()+'}' ~~>		= "[" expression <~~push(up.in)~~> "]" ;
repetition		<~~ up.in = '{"REPEAT", '+pop()+'}' ~~>			= "{" expression <~~push(up.in)~~> "}" ;
skipspaces		=
				"+"						<~~ up.in = '{"SKIPSPACES", true}' ~~>
				|
				"-"						<~~ up.in = '{"SKIPSPACES", false}' ~~> ;

title			= text ;
start			= name					<~~ up.in = '{"IDENT", "'+up.in+'", '+getNameIdx(up.in)+'}' ~~> ;
comment			= text ;

tag										<~~up.in=pop()~~>
				=
				"<"
				code					<~~push(up.in)~~>
				{
					","
					code				<~~ push(pop()+', '+up.in) ~~>
				}
				">" ;

code									<~~ up.in = '{"TERMINAL", '+sprintf("%q",pop())+'}' ~~>
				=
				'~~'
				-
				{ [ "~" ] codeinner }	<~~push(up.in)~~>
				'~~'
				+ ;

codeinner        = small | caps | digit | special | "'" | '"' | "\\~" ;

name             = ( small | caps ) - { small | caps | digit | "_" } + ;

text									<~~ up.in = '{"TERMINAL", '+sprintf("%q",pop())+'}' ~~>
				= dquotetext | squotetext ;
dquotetext		= '"' - { small | caps | digit | special | "~" | "'" | '\\"' } <~~push(up.in)~~> '"' + ;
squotetext		= "'" - { small | caps | digit | special | "~" | '"' | "\\'" } <~~push(up.in)~~> "'" + ;

digit			= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
small			= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" |
				  "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
caps			= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" |
				  "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
special			= "_" | " " | "." | "," | ":" | ";" | "!" | "?" | "+" | "-" | "*" | "/" | "=" |
				  "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">" | "|" | "%" | "$" | "&" | "#" |
				  "@" | "\\\\" | "\\t" | "\t" | "\\n" | "\n" | "\\r" | "\r" ;

}

<~~ print(pop()) ~~>
program
"This aEBNF contains the grammatic and semantic information for annotated EBNF.
It allows to automatically create a compiler for everything described in aEBNF (yes, that format)."
