"aEBNF of aEBNF as text"
<~~
var names = [];
function getNameIdx(name) {
  var pos = names.indexOf(name);
  if (pos != -1) { return pos };
  return names.push(name)-1;
}
c.compile(c.asg, upstream)
~~>

{

program          = [ title <~~ upstream.str += ', \\n' ~~> ] programtag "{" <~~ upstream.str = '\\n{\\n\\n' ~~> { production } "}" <~~ upstream.str = '\\n}, \\n\\n' ~~> programtag start [ comment <~~ upstream.str = ', \\n'+upstream.str+'\\n' ~~> ] ;
programtag       = [ tag <~~ upstream.str = '{"TAG", '+upstream.str+'}, \\n' ~~> ] ;
production       <~~ if (upstream.productionTag != undefined) { upstream.str = '{"TAG", '+upstream.productionTag+', '+upstream.str+'}' }; upstream.str += ', \\n' ~~>       
				 = name <~~ upstream.str = '{"'+upstream.str+'", '+getNameIdx(upstream.str)+', ' ~~> [ tag ] <~~ upstream.productionTag = upstream.str; upstream.str = '' ~~> "=" <~~ upstream.str = '' ~~> [ expression ] ( "." | ";" ) <~~ upstream.str = '}' ~~> ;
expression       <~~ if (upstream.or) { upstream.str = '{"OR", '+upstream.str+'}' } ~~>   
				 = alternative <~~ upstream.or = false ~~> { "|" <~~ upstream.str = '' ~~> alternative <~~ upstream.or = true; upstream.str = ', '+upstream.str ~~> } ;
alternative      = taggedterm { taggedterm <~~ upstream.str = ', '+upstream.str ~~> } ;

taggedterm       <~~ if (upstream.termTag != undefined) { upstream.str = '{"TAG", '+upstream.termTag+', '+upstream.str+'}' } ~~>
				 = term <~~ upstream.termTag = undefined ~~> [ tag <~~ upstream.termTag = upstream.str; upstream.str = '' ~~> ] ;

term             = ( name <~~ upstream.str = '{"IDENT", "'+upstream.str+'", '+getNameIdx(upstream.str)+'}' ~~> | ( text [ "..." text ] ) | group | option | repetition | skipspaces ) ;
group            <~~ upstream.str = '{'+upstream.str+'}' ~~>                              = "(" <~~ upstream.str = '' ~~> expression ")" <~~ upstream.str = '' ~~> ;
option           <~~ upstream.str = '{"OPTIONAL", '+upstream.str+'}' ~~>                  = "[" <~~ upstream.str = '' ~~> expression "]" <~~ upstream.str = '' ~~> ;
repetition       <~~ upstream.str = '{"REPEAT", '+upstream.str+'}' ~~>                    = "{" <~~ upstream.str = '' ~~> expression "}" <~~ upstream.str = '' ~~> ;
skipspaces       = "+" <~~ upstream.str = '{"SKIPSPACES", true}' ~~> | "-" <~~ upstream.str = '{"SKIPSPACES", false}' ~~> ;

title            = text ;
start            = name <~~ upstream.str = '{"IDENT", "'+upstream.str+'", '+getNameIdx(upstream.str)+'}' ~~> ;
comment          = text ;

tag              = "<" <~~ upstream.str = '' ~~> code { "," <~~ upstream.str = '' ~~> code <~~ upstream.str = ', '+upstream.str ~~> } ">" <~~ upstream.str = '' ~~> ;

code             <~~ upstream.str = '{"TERMINAL", '+sprintf("%q",upstream.str)+'}' ~~>                  = '~~' <~~ upstream.str = '' ~~> - { [ "~" ] codeinner } '~~' <~~ upstream.str = '' ~~> + ;
codeinner        = small | caps | digit | special | "'" | '"' | "\\~" ;

name             = ( small | caps ) - { small | caps | digit | "_" } + ;

text             <~~ upstream.str = '{"TERMINAL", '+sprintf("%q",upstream.str)+'}' ~~>                  = dquotetext | squotetext ;
dquotetext       = '"' <~~ upstream.str = '' ~~> - { small | caps | digit | special | "~" | "'" | '\\"' } '"' <~~ upstream.str = '' ~~> + ;
squotetext       = "'" <~~ upstream.str = '' ~~> - { small | caps | digit | special | "~" | '"' | "\\'" } "'" <~~ upstream.str = '' ~~> + ;

digit            = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
small            = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" ;
caps             = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;
special          = "_" | " " | "." | "," | ":" | ";" | "!" | "?" | "+" | "-" | "*" | "/" | "=" | "(" | ")" | "{" | "}" | "[" | "]" | "<" | ">" | "\\\\" | "\\n" | "\n" | "\\t" | "\t" | "|" | "%" | "$" | "&" | "#" | "@" ;

}

<~~ print(upstream.str)

println("\\n\\nTHE FOLLOWING IS NOT FROM THE ABOVE CODE BUT ONLY A TEST")

println("\\nLLVM IR test:\\n------------------------------------")

// Create convenience types and constants.
var i32 = llvm.types.I32

// Create a new LLVM IR module.
var m = llvm.ir.NewModule()

// -----------------

var zero = llvm.constant.NewInt(i32, 0)
var a = llvm.constant.NewInt(i32, 0x15A4E35) // multiplier of the PRNG.
var c = llvm.constant.NewInt(i32, 1)         // increment of the PRNG.

// Create an external function declaration and append it to the module.
//
//    int abs(int x);
var abs = m.NewFunc("abs", i32, llvm.ir.NewParam("x", i32))

// Create a global variable definition and append it to the module.
//
//    int seed = 0;
var seed = m.NewGlobalDef("seed", zero)

// Create a function definition and append it to the module.
//
//    int rand(void) { ... }
var rand = m.NewFunc("rand", i32)

// Create an unnamed entry basic block and append it to the 'rand' function.
var entry = rand.NewBlock("")

// Create instructions and append them to the entry basic block.
var tmp1 = entry.NewLoad(i32, seed)
var tmp2 = entry.NewMul(tmp1, a)
var tmp3 = entry.NewAdd(tmp2, c)
entry.NewStore(tmp3, seed)
var tmp4 = entry.NewCall(abs, tmp3)
entry.NewRet(tmp4)

// -----------------

// int test() { ... }
var test = m.NewFunc("test", i32)

// Create an unnamed entry basic block and append it to the 'test' function.
var entry = test.NewBlock("")
// Create instructions and append them to the entry basic block.

// %3 = add 
var tmp = entry.NewAdd(llvm.constant.NewInt(i32, 32), llvm.constant.NewInt(i32, 32))

// ret i32 %3
entry.NewRet(tmp)

// -----------------

// Print the LLVM IR assembly of the module.
println(m)

println("GRAPH:\\n------------------------------------")
println(llvm.Callgraph(m))

println("\\nEVAL:\\n------------------------------------")
println(llvm.Eval(m, "test"))

~~>
program
"This aEBNF contains the grammatic and semantic information for annotated EBNF.
It allows to automatically create a compiler for everything described in aEBNF (yes, that format)."
