package abnf

import "14.gy/mec/abnf/r"

// ----------------------------------------------------------------------------
// Parser agrammar

var AbnfAgrammar = &r.Rules{&r.Rule{Operator: r.Command, String: "title", CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "ABNF of ABNF to a-grammar"}}}, &r.Rule{Operator: r.Command, String: "description", CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "This ABNF contains the grammatic and semantic information for annotated EBNF.\nIt allows to automatically create a compiler for everything described in ABNF (yes, that format)."}}}, &r.Rule{Operator: r.Command, String: "startRule", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "ABNF"}}}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}, &r.Rule{Operator: r.Production, String: "ABNF", Childs: &r.Rules{&r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Production"}, &r.Rule{Operator: r.Identifier, String: "LineCommand"}}}}}}}, &r.Rule{Operator: r.Production, String: "Production", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " var prodTag=undefined; var prodExpression=undefined; pushg(pop()) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Name"}}}, &r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " prodTag=pop() "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Tag"}}}}}, &r.Rule{Operator: r.Token, String: "="}, &r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " prodExpression=pop() "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Expression"}}}}}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "  pushg(buildProduction(popg(), prodTag, prodExpression)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: ";"}}}}}, &r.Rule{Operator: r.Production, String: "Expression", Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Alternative"}}}, &r.Rule{Operator: r.Production, String: "Alternative", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(simplify(abnf.newAlternative(popg(), c.Pos))) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg([pop()]) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Sequence"}}}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "|"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(append(popg(), pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Sequence"}}}}}}}}}, &r.Rule{Operator: r.Production, String: "Sequence", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(simplify(abnf.newSequence(popg(), c.Pos))) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg([pop()]) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Term"}}}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(append(popg(), pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Term"}}}}}}}}}, &r.Rule{Operator: r.Production, String: "Term", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(popg()) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(simplify(pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Name"}, &r.Rule{Operator: r.Identifier, String: "ByteRange"}, &r.Rule{Operator: r.Identifier, String: "Range"}, &r.Rule{Operator: r.Identifier, String: "CharsOf"}, &r.Rule{Operator: r.Identifier, String: "CharOf"}, &r.Rule{Operator: r.Identifier, String: "Group"}, &r.Rule{Operator: r.Identifier, String: "Option"}, &r.Rule{Operator: r.Identifier, String: "Repetition"}, &r.Rule{Operator: r.Identifier, String: "Times"}, &r.Rule{Operator: r.Identifier, String: "Command"}}}}}, &r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " var tag=pop(); tag.Childs=simplifyToArr(popg()); pushg(tag) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Tag"}}}}}}}}}, &r.Rule{Operator: r.Production, String: "Group", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "("}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newGroup(simplifyToArr(pop()), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Expression"}}}, &r.Rule{Operator: r.Token, String: ")"}}}, &r.Rule{Operator: r.Production, String: "Option", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "["}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newOption(simplifyToArr(pop()), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Expression"}}}, &r.Rule{Operator: r.Token, String: "]"}}}, &r.Rule{Operator: r.Production, String: "Repetition", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "{"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newRepetition(simplifyToArr(pop()), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Expression"}}}, &r.Rule{Operator: r.Token, String: "}"}}}, &r.Rule{Operator: r.Production, String: "Range", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(popg()) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(pop()) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Token"}}}, &r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "..."}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(abnf.newRange([popg(), pop()], abnf.rangeType.Rune, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Token"}}}}}}}}}, &r.Rule{Operator: r.Production, String: "ByteRange", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(pop()) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Token"}}}, &r.Rule{Operator: r.Token, String: "..b"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newRange([popg(), pop()], abnf.rangeType.Byte, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Token"}}}}}, &r.Rule{Operator: r.Production, String: "CharsOf", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "@+"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newCharsOf(pop().String, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Token"}}}}}, &r.Rule{Operator: r.Production, String: "CharOf", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "@"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newCharOf(pop().String, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Token"}}}}}, &r.Rule{Operator: r.Production, String: "Times", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg([pop()]) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "CmdNumber"}}}, &r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "..."}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(append(popg(), pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "CmdNumber"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newToken(\"...\")) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: ""}}}}}}}}}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newTimes(popg(), simplifyToArr(pop()), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Group"}}}}}, &r.Rule{Operator: r.Production, String: "CmdNumber", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Number"}, &r.Rule{Operator: r.Identifier, String: "Command"}}}}}, &r.Rule{Operator: r.Production, String: "LineCommand", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(pop()) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Command"}}}, &r.Rule{Operator: r.Token, String: ";"}}}, &r.Rule{Operator: r.Production, String: "Command", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newCommand(pop(), popg(), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: ":"}, &r.Rule{Operator: r.Identifier, String: "CmdName"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg([]) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "("}}}, &r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(append(popg(), pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Name"}, &r.Rule{Operator: r.Identifier, String: "Token"}, &r.Rule{Operator: r.Identifier, String: "Number"}}}}}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: ","}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(append(popg(), pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Name"}, &r.Rule{Operator: r.Identifier, String: "Token"}, &r.Rule{Operator: r.Identifier, String: "Number"}}}}}}}}}, &r.Rule{Operator: r.Token, String: ")"}}}}}, &r.Rule{Operator: r.Production, String: "Tag", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newTag(popg(), undefined, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "<"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg([pop()]) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Name"}, &r.Rule{Operator: r.Identifier, String: "Token"}}}}}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: ","}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " pushg(append(popg(), pop())) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Name"}, &r.Rule{Operator: r.Identifier, String: "Token"}}}}}}}, &r.Rule{Operator: r.Token, String: ">"}}}}}, &r.Rule{Operator: r.Production, String: "Name", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newIdentifier(up.in, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Alphabet"}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Alphabet"}, &r.Rule{Operator: r.Identifier, String: "Digit"}, &r.Rule{Operator: r.Token, String: "_"}}}}}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}}}, &r.Rule{Operator: r.Production, String: "CmdName", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(up.in) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Alphabet"}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Alphabet"}, &r.Rule{Operator: r.Identifier, String: "Digit"}, &r.Rule{Operator: r.Token, String: "_"}}}}}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}}}, &r.Rule{Operator: r.Production, String: "Token", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Dquotetoken"}, &r.Rule{Operator: r.Identifier, String: "Squotetoken"}, &r.Rule{Operator: r.Identifier, String: "Code"}}}}}, &r.Rule{Operator: r.Production, String: "Dquotetoken", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "\""}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newToken(unescape(up.in), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "AsciiNoQs"}, &r.Rule{Operator: r.Token, String: "'"}, &r.Rule{Operator: r.Token, String: "\\\""}}}}}}}, &r.Rule{Operator: r.Token, String: "\""}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}, &r.Rule{Operator: r.Production, String: "Squotetoken", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "'"}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newToken(unescape(up.in), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "AsciiNoQs"}, &r.Rule{Operator: r.Token, String: "\""}, &r.Rule{Operator: r.Token, String: "\\'"}}}}}}}, &r.Rule{Operator: r.Token, String: "'"}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}, &r.Rule{Operator: r.Production, String: "Code", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "~~"}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newToken(unescapeTilde(up.in), c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Optional, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "~"}}}, &r.Rule{Operator: r.Identifier, String: "AllButTilde"}}}}}, &r.Rule{Operator: r.Token, String: "~~"}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}, &r.Rule{Operator: r.Production, String: "Alphabet", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "a"}, &r.Rule{Operator: r.Token, String: "z"}}}, &r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "A"}, &r.Rule{Operator: r.Token, String: "Z"}}}}}}}, &r.Rule{Operator: r.Production, String: "Digit", Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "0"}, &r.Rule{Operator: r.Token, String: "9"}}}}}, &r.Rule{Operator: r.Production, String: "AsciiNoQs", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "("}, &r.Rule{Operator: r.Token, String: "~"}}}, &r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "#"}, &r.Rule{Operator: r.Token, String: "&"}}}, &r.Rule{Operator: r.CharOf, String: "\t\n\r !"}}}}}, &r.Rule{Operator: r.Production, String: "AsciiNoLb", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " "}, &r.Rule{Operator: r.Token, String: "~"}}}, &r.Rule{Operator: r.Token, String: "\t"}}}}}, &r.Rule{Operator: r.Production, String: "AsciiNoStSl", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "\x00"}, &r.Rule{Operator: r.Token, String: ")"}}}, &r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "+"}, &r.Rule{Operator: r.Token, String: "."}}}, &r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "0"}, &r.Rule{Operator: r.Token, String: "~"}}}}}}}, &r.Rule{Operator: r.Production, String: "AllButTilde", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "\x00"}, &r.Rule{Operator: r.Token, String: "}"}}}, &r.Rule{Operator: r.Token, String: "\\~"}, &r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "\u007f"}, &r.Rule{Operator: r.Token, String: "\uffff"}}}}}}}, &r.Rule{Operator: r.Production, String: "Number", Childs: &r.Rules{&r.Rule{Operator: r.Tag, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: " push(abnf.newNumber(up.in, c.Pos)) "}}, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "0"}, &r.Rule{Operator: r.Sequence, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "1"}, &r.Rule{Operator: r.Token, String: "9"}}}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Range, Int: 0, CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "0"}, &r.Rule{Operator: r.Token, String: "9"}}}}}}}}}}}}}, &r.Rule{Operator: r.Production, String: "Whitespace", Childs: &r.Rules{&r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.CharsOf, String: "\t\n\r "}, &r.Rule{Operator: r.Identifier, String: "Comment"}}}}}}}, &r.Rule{Operator: r.Production, String: "Comment", Childs: &r.Rules{&r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "LineComment"}, &r.Rule{Operator: r.Sequence, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "/*"}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "*"}}}, &r.Rule{Operator: r.Identifier, String: "AsciiNoStSl"}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "/"}}}}}, &r.Rule{Operator: r.Token, String: "*/"}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}}}}}, &r.Rule{Operator: r.Production, String: "LineComment", Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "//"}, &r.Rule{Operator: r.Command, String: "whitespace"}, &r.Rule{Operator: r.Repeat, Childs: &r.Rules{&r.Rule{Operator: r.Identifier, String: "AsciiNoLb"}}}, &r.Rule{Operator: r.Or, Childs: &r.Rules{&r.Rule{Operator: r.Token, String: "\n"}, &r.Rule{Operator: r.Token, String: "\r"}}}, &r.Rule{Operator: r.Command, String: "whitespace", CodeChilds: &r.Rules{&r.Rule{Operator: r.Identifier, String: "Whitespace"}}}}}, &r.Rule{Operator: r.Command, String: "startScript", CodeChilds: &r.Rules{&r.Rule{Operator: r.Token, String: "\n\n    function buildProduction(prodName, prodTag, prodExpression) {\n        if (prodTag != undefined) {\n            prodTag.Childs = simplifyToArr(prodExpression)\n            return abnf.newProduction(prodName.String, [prodTag], prodName.Pos)\n        } else {\n            return abnf.newProduction(prodName.String, simplifyToArr(prodExpression), prodName.Pos)\n        }\n    }\n\n    // This breaks up an abnf.oid.Group. Use only for childs of unbreakable rules.\n    function simplifyArr(rules) {\n        if (rules.length == 1) {\n            const op = rules[0].Operator\n            if (op == abnf.oid.Sequence || op == abnf.oid.Group || (op == abnf.oid.Or && rules[0].Childs.length <= 1)) return simplifyArr(rules[0].Childs)\n        }\n        return rules\n    }\n\n    // This also breaks up an abnf.oid.Group. Use only for childs of unbreakable rules.\n    function simplifyToArr(rule) {\n        if (rule == undefined) return undefined\n        return simplifyArr([rule])\n    }\n\n    // Groups with only one child can be broken apart as long as down there is an unbreakable rule. Try to find one.\n    function trySimplifyDown(rule) {\n        if (rule.Childs == undefined) return rule\n        const op = rule.Operator\n        if ((rule.Childs.length == 1) && (op == abnf.oid.Sequence || op == abnf.oid.Group || op == abnf.oid.Or)) return trySimplifyDown(rule.Childs[0])\n        if (op == abnf.oid.Sequence) return undefined\n        return rule\n    }\n\n    function simplify(rule) {\n        let ruleDown = trySimplifyDown(rule)\n        if (ruleDown != undefined) return ruleDown\n        if (rule.Childs.length == 1) { // Breaking up abnf.oid.Group did not work. Getting down only with Sequence and Or.\n            const op = rule.Operator\n            if (op == abnf.oid.Sequence || op == abnf.oid.Or) return simplify(rule.Childs[0])\n        }\n        return rule\n    }\n\n    c.compile(c.asg)\n    let rules = ltr.stack\n\n    // To show the initial a-grammar:\n//    println(\"=> Rules: \" + abnf.serializeRules(rules))\n\n    // To return the generated a-grammar to the next parser:\n    rules\n\n"}}}}
